#ifdef USE_ADVANCED_SHADERS
#include "settings_screenspace_PUDDLES.h"
#include "settings_screenspace_SSR.h"

#include "common.h"
#include "sload.h"

#include "screenspace_common_ripples.h"
		

Texture2D s_puddles_normal;
Texture2D s_puddles_perlin;
Texture2D s_puddles_mask;
Texture2D s_rainsplash;

#define USE_TDETAIL

#define PARALLAX_NEAR_PLANE 0.001
#define PARALLAX_FAR_PLANE 30
#define PARALLAX_DEPTH 0.060

//Height maps
Texture2D s_dnE_r;
Texture2D s_dnE_g;
Texture2D s_dnE_b;
Texture2D s_dnE_a;

struct surface {
	float4 base;
	float3 normal;
	float  gloss;
	float  layer;
};

// returns height
float perform_tc_offset(inout p_bumped p, in Texture2D s_bumpX_new)
{
	float h = 0;
	if ((p.position.z > PARALLAX_NEAR_PLANE) && (p.position.z < PARALLAX_FAR_PLANE))
	{
		float3 eye = normalize(mul(float3x3(p.M1.x, p.M2.x, p.M3.x,
			p.M1.y, p.M2.y, p.M3.y,
			p.M1.z, p.M2.z, p.M3.z), -p.position));

		// steps minmax and refines minmax
		int4 steps = int4(6, 8, 6, 12); // 3..10, 7..16

		bool need_disp_lerp = true;
		bool need_refine = true;

		float view_angle = abs(dot(float3(0.0, 0.0, 1.0), eye));

		float layer_step = rcp(lerp(steps.y, steps.x, view_angle));

		float2 tc_step = layer_step * eye.xy * PARALLAX_DEPTH;

		float2 displaced_tc = p.tcdbump;

		float curr_disp, curr_layer = 0.0;

		do
		{
			displaced_tc -= tc_step;
			curr_disp = 1 - s_bumpX_new.SampleLevel(smp_base, displaced_tc, 0).w;
			curr_layer += layer_step;
		} while (curr_layer < curr_disp);

		if (need_refine)
		{
			displaced_tc += tc_step;
			curr_layer -= layer_step;

			float refine_steps = lerp(steps.w, steps.z, view_angle);

			tc_step /= refine_steps;
			layer_step /= refine_steps;

			do
			{
				displaced_tc -= tc_step;
				curr_disp = 1.0 - s_bumpX_new.SampleLevel(smp_base, displaced_tc, 0).w;
				curr_layer += layer_step;
			} while (curr_layer < curr_disp);
		}

		if (need_disp_lerp)
		{
			float2 displaced_tc_prev = displaced_tc + tc_step;

			float after_depth = curr_disp - curr_layer;
			float before_depth = 1.0 - s_bumpX_new.SampleLevel(smp_base, displaced_tc_prev, 0).w - curr_layer + layer_step;

			float weight = after_depth / (after_depth - before_depth);

			displaced_tc = lerp(displaced_tc, displaced_tc_prev, weight);
		}

		p.tcdbump = displaced_tc;
		h = saturate(curr_layer);
	}
	return h;
}

surface fill(p_bumped p, Texture2D s_base_det, Texture2D s_bump_det, Texture2D s_bumpX_det, uint need_mask, float mask)
{
	surface S;

	mask = need_mask ? mask : 1;

	if (mask <= 0)
	{
		S.base = (0.0, 0.0, 0.0, 0.0);
		S.gloss = 0.0;
		S.normal = (0.0, 0.0, 0.0);
		S.layer = 0;
		return S;
	}

	float h = perform_tc_offset(p, s_base_det);
	S.layer = h*mask;
	
	S.base = s_base_det.Sample(smp_base, p.tcdbump) * mask;

	float4 Nu = s_bump_det.Sample(smp_base, p.tcdbump);

	S.gloss = Nu.x * mask;
	S.normal = (Nu.wzy - 0.5) * mask;

	return S;
}


f_deffer main(p_bumped I)
{
	float4 C = s_base.Sample(smp_base, I.tcdh.xy);

	float4 mask = s_mask.Sample(smp_base, I.tcdh.xy);
	mask /= dot(mask, 1.0);



////////////////////////puddles///////////////////////////////

	// Puddles Implementation - SSS Update 14.6
	// https://www.moddb.com/mods/stalker-anomaly/addons/screen-space-shaders/

	// Wetness factor
	float wetness_f = rain_params.y;

	// Always render puddles if G_PUDDLES_ALLWAYS is defined
	#ifdef G_PUDDLES_ALLWAYS
		wetness_f = 1.0f;
	#endif

	// Intensity factor.
	float puddles_f = wetness_f;

	// Size factor. Convert 0 ~ 1 to 1 ~ -0.1f
	float size_f = (1.0f - G_PUDDLES_SIZE * 1.1f);

	// Texture mask
	float puddles_mask = 1.0f - s_puddles_mask.Sample(smp_base, I.tcdh).r;

	// Puddles perlin
	float puddles = saturate((s_puddles_perlin.Sample(smp_base, I.tcdh * 15.0f / G_PUDDLES_GLOBAL_SIZE).r - size_f) * puddles_f);

	// Get normals and transform space to create a slope mask
	float3 N1 = mul(float3x3(I.M1, I.M2, I.M3), float3(0,0,1));
	float3 N2 = mul(m_inv_V, normalize(N1));

	// Slope mask
	float slope = max(N2.x, N2.y);

	// Slope adjustements... Some magic numbers
	slope = saturate((slope - 0.997f) * (102.0f + 0.997f));

	// Slope & texture mask defines final puddles intensity
	puddles *= slope * puddles_mask;

	// Puddles border hardness
	puddles = smoothstep(0, saturate(0.3f - G_PUDDLES_BORDER_HARDNESS * 0.3f), puddles);

#ifdef G_PUDDLES_RIPPLES

	float rain_int = saturate(rain_params.x * 1.5f);

	// Base ripples anim speed
	float ripples_anim =  timers.x * ((0.01f + (rain_int * 0.008f)) * G_PUDDLES_RIPPLES_SPEED );
	
	// Base ripples scale
	float ripples_scale = 140 / G_PUDDLES_RIPPLES_SCALE;

	// Base ripples Normal
	float3 WN0 = s_puddles_normal.Sample(smp_base, I.tcdh * ripples_scale + float2(0, ripples_anim));
	float3 WN1 = s_puddles_normal.Sample(smp_base, I.tcdh * ripples_scale - float2(0.33f, ripples_anim));
	float3 ripplesNormal = ((WN0 * 2 - 1) + (WN1 * 2 - 1)) / 2.0f;

	// Rain Ripples
	float3 rainRipples = SSFX_ripples( s_rainsplash, I.tcdh * ripples_scale * 2.8f / G_PUDDLES_RAIN_RIPPLES_SCALE ) * 2 - 1;

	// Rain ripples intensity... ( Rain intensity * Depth fadeout * Intensity )
	rainRipples *= clamp(1.5f - I.position.z * 0.15f, 0.3f, 1.0f) * rain_params.x * 3.0f * G_PUDDLES_RAIN_RIPPLES_INTENSITY;

	// Base ripples Intensity
	ripplesNormal *= (0.05f + rain_int * G_PUDDLES_RIPPLES_RAINING_INT) * G_PUDDLES_RIPPLES_INTENSITY;
	
	// Mix ripples
	ripplesNormal = ( ripplesNormal * 0.666f ) + ( rainRipples * 0.333f );

#else
	float3 ripplesNormal = 0;
#endif

	// Normal Up and ripples for puddles
	float3 MirrorUp	= mul(m_V,  float3(ripplesNormal.x, 1.0f, ripplesNormal.y));
	//N = lerp(N, MirrorUp, puddles);

	// Refraction Normal
	float3 N_refra = ripplesNormal;

	// Adjust refraction intensity based on wetness and puddle perlin
	N_refra.xy *= 0.15f * smoothstep( 0.6f, 0.8f, wetness_f * puddles ) * G_PUDDLES_REFRACTION_INTENSITY;

	// Detail textures + refraction when needed
	/*float2 detail_tc = I.tcdbump + N_refra;
	float3 d_R = s_dt_r.Sample ( smp_base, detail_tc) * mask.r;
	float3 d_G = s_dt_g.Sample ( smp_base, detail_tc) * mask.g;
	float3 d_B = s_dt_b.Sample ( smp_base, detail_tc) * mask.b;
	float3 d_A = s_dt_a.Sample ( smp_base, detail_tc) * mask.a;
	float3 dt = d_R + d_G + d_B + d_A;
	D.rgb = 2 * D.rgb * dt;*/

	I.tcdh += N_refra * dt_params; // hack
	I.tcdbump += N_refra; // hack
	surface Sr = fill(I, s_dt_r, s_dn_r, s_dnE_r, 1, mask.r);
	surface Sg = fill(I, s_dt_g, s_dn_g, s_dnE_g, 1, mask.g);
	surface Sb = fill(I, s_dt_b, s_dn_b, s_dnE_b, 1, mask.b);
	surface Sa = fill(I, s_dt_a, s_dn_a, s_dnE_a, 1, mask.a);

	C.xyz = (Sr.base.xyz + Sg.base.xyz + Sb.base.xyz + Sa.base.xyz) * C.xyz * 2.0;

	float4 Ne = float4(normalize(mul(float3x3(I.M1, I.M2, I.M3), Sr.normal + Sg.normal + Sb.normal + Sa.normal)), C.w);

	// Apply tint
	//D.rgb = lerp( D.rgb, D.rgb * G_PUDDLES_TINT, puddles);

	// Limit pudddle reflection.
	puddles = clamp(puddles, 0, G_PUDDLES_REFLECTIVITY);

	// Add at the end the extra wetness. Full intensity at 50% of wetness ( rain_params.y )
	//puddles = puddles + saturate(rain_params.y * 2.0f) * G_PUDDLES_TERRAIN_EXTRA_WETNESS;
	
	// parallax puddles
	float H = Sr.layer+Sg.layer+Sb.layer+Sa.layer;
	float contrast = 0.15;
	float base_height = 0.5;
	float puddle_mask_parallax = smoothstep(base_height-contrast, base_height+contrast, H)*wetness_f;
	puddles = max(puddles, puddle_mask_parallax);
	
	C.rgb = lerp( C.rgb, C.rgb * G_PUDDLES_TINT, puddles);

	// Add gloss and puddles to the final gloss result
	//G = max(g_R + g_G + g_B + g_A, puddles);
	float G = Sr.gloss + Sg.gloss + Sb.gloss + Sa.gloss;
	
	G = max(G, puddles);	
	Ne.xyz = lerp(Ne.xyz, MirrorUp, puddles);

////////////////////////puddles - end///////////////////////////////

#ifdef USE_R2_STATIC_SUN
	float ms = s_lmap.Sample(smp_base, I.tcdh.xy).w;
#else
	float ms = xmaterial;
#endif

	return pack_gbuffer(
		Ne, // normal.hemi
		float4(I.position.xyz, ms), // depth.( mtl or sun )
		float4(C.rgb, G * 0.5) // color.gloss
	);
}

#else


#include "settings_screenspace_PUDDLES.h"
#include "settings_screenspace_SSR.h"

#include "common.h"
#include "sload.h"

#include "screenspace_common_ripples.h"
		

Texture2D s_puddles_normal;
Texture2D s_puddles_perlin;
Texture2D s_puddles_mask;
Texture2D s_rainsplash;

#define	USE_4_DETAIL

#if defined(USE_TDETAIL) && defined(USE_4_DETAIL)
#	define	USE_4_BUMP
#endif

#ifdef USE_4_BUMP
f_deffer main(p_bumped I)
#else
f_deffer 	main	( p_flat I 		)
#endif
{
	f_deffer	O;

 	// diffuse
	float4 D		= tbase		(I.tcdh);			// IN:  rgb.a
	float4 L 	= s_lmap.Sample( smp_base, I.tcdh);
	float G 	= 0.001;

#ifdef	USE_TDETAIL
 #ifdef USE_4_DETAIL
	float4	mask= s_mask.Sample ( smp_base, I.tcdh);
	float 	mag	= dot 		(mask,1);
			mask= mask/mag	;

  #ifdef USE_4_BUMP
 	 float4	n_Rt = s_dn_r.Sample ( smp_base, I.tcdbump).wzyx;
	 float4	n_Gt = s_dn_g.Sample ( smp_base, I.tcdbump).wzyx;
	 float4	n_Bt = s_dn_b.Sample ( smp_base, I.tcdbump).wzyx;
	 float4	n_At = s_dn_a.Sample ( smp_base, I.tcdbump).wzyx;
	 
 	 float3	n_R = (n_Rt-0.5)*mask.r; 
	 float g_R=n_Rt.w*mask.r;
	 
	 float3	n_G = (n_Gt-0.5)*mask.g; 
	 float g_G=n_Gt.w*mask.g;
	 
	 float3	n_B = (n_Bt-0.5)*mask.b; 
	 float g_B=n_Bt.w*mask.b;
	 
	 float3	n_A = (n_At-0.5)*mask.a; 
	 float g_A=n_At.w*mask.a;

	 float3	mix		= 	n_R+n_G+n_B+n_A;
			mix	*=	float3(G_SSR_TERRAIN_BUMP_INTENSITY, G_SSR_TERRAIN_BUMP_INTENSITY, 1); // Adjust bump strength

	 float3	N		= 	mul     	(float3x3(I.M1, I.M2, I.M3), mix.xyz);

	// Puddles Implementation - SSS Update 14.6
	// https://www.moddb.com/mods/stalker-anomaly/addons/screen-space-shaders/

	// Wetness factor
	float wetness_f = rain_params.y;

	// Always render puddles if G_PUDDLES_ALLWAYS is defined
	#ifdef G_PUDDLES_ALLWAYS
		wetness_f = 1.0f;
	#endif

	// Intensity factor.
	float puddles_f = wetness_f;

	// Size factor. Convert 0 ~ 1 to 1 ~ -0.1f
	float size_f = (1.0f - G_PUDDLES_SIZE * 1.1f);

	// Texture mask
	float puddles_mask = 1.0f - s_puddles_mask.Sample(smp_base, I.tcdh).r;

	// Puddles perlin
	float puddles = saturate((s_puddles_perlin.Sample(smp_base, I.tcdh * 15.0f / G_PUDDLES_GLOBAL_SIZE).r - size_f) * puddles_f);

	// Get normals and transform space to create a slope mask
	float3 N1 = mul(float3x3(I.M1, I.M2, I.M3), float3(0,0,1));
	float3 N2 = mul(m_inv_V, normalize(N1));

	// Slope mask
	float slope = max(N2.x, N2.y);

	// Slope adjustements... Some magic numbers
	slope = saturate((slope - 0.997f) * (102.0f + 0.997f));

	// Slope & texture mask defines final puddles intensity
	puddles *= slope * puddles_mask;

	// Puddles border hardness
	puddles = smoothstep(0, saturate(0.3f - G_PUDDLES_BORDER_HARDNESS * 0.3f), puddles);

#ifdef G_PUDDLES_RIPPLES

	float rain_int = saturate(rain_params.x * 1.5f);

	// Base ripples anim speed
	float ripples_anim =  timers.x * ((0.01f + (rain_int * 0.008f)) * G_PUDDLES_RIPPLES_SPEED );
	
	// Base ripples scale
	float ripples_scale = 140 / G_PUDDLES_RIPPLES_SCALE;

	// Base ripples Normal
	float3 WN0 = s_puddles_normal.Sample(smp_base, I.tcdh * ripples_scale + float2(0, ripples_anim));
	float3 WN1 = s_puddles_normal.Sample(smp_base, I.tcdh * ripples_scale - float2(0.33f, ripples_anim));
	float3 ripplesNormal = ((WN0 * 2 - 1) + (WN1 * 2 - 1)) / 2.0f;

	// Rain Ripples
	float3 rainRipples = SSFX_ripples( s_rainsplash, I.tcdh * ripples_scale * 2.8f / G_PUDDLES_RAIN_RIPPLES_SCALE ) * 2 - 1;

	// Rain ripples intensity... ( Rain intensity * Depth fadeout * Intensity )
	rainRipples *= clamp(1.5f - I.position.z * 0.15f, 0.3f, 1.0f) * rain_params.x * 3.0f * G_PUDDLES_RAIN_RIPPLES_INTENSITY;

	// Base ripples Intensity
	ripplesNormal *= (0.05f + rain_int * G_PUDDLES_RIPPLES_RAINING_INT) * G_PUDDLES_RIPPLES_INTENSITY;
	
	// Mix ripples
	ripplesNormal = ( ripplesNormal * 0.666f ) + ( rainRipples * 0.333f );

#else
	float3 ripplesNormal = 0;
#endif

	// Normal Up and ripples for puddles
	float3 MirrorUp	= mul(m_V,  float3(ripplesNormal.x, 1.0f, ripplesNormal.y));
	N = lerp(N, MirrorUp, puddles);

	// Refraction Normal
	float3 N_refra = ripplesNormal;

	// Adjust refraction intensity based on wetness and puddle perlin
	N_refra.xy *= 0.15f * smoothstep( 0.6f, 0.8f, wetness_f * puddles ) * G_PUDDLES_REFRACTION_INTENSITY;

	// Detail textures + refraction when needed
	float2 detail_tc = I.tcdbump + N_refra;
	float3 d_R = s_dt_r.Sample ( smp_base, detail_tc) * mask.r;
	float3 d_G = s_dt_g.Sample ( smp_base, detail_tc) * mask.g;
	float3 d_B = s_dt_b.Sample ( smp_base, detail_tc) * mask.b;
	float3 d_A = s_dt_a.Sample ( smp_base, detail_tc) * mask.a;
	float3 dt = d_R + d_G + d_B + d_A;
	D.rgb = 2 * D.rgb * dt;

	// Apply tint
	D.rgb = lerp( D.rgb, D.rgb * G_PUDDLES_TINT, puddles);

	// Limit pudddle reflection.
	puddles = clamp(puddles, 0, G_PUDDLES_REFLECTIVITY);

	// Add at the end the extra wetness. Full intensity at 50% of wetness ( rain_params.y )
	puddles = puddles + saturate(rain_params.y * 2.0f) * G_PUDDLES_TERRAIN_EXTRA_WETNESS;

	// Add gloss and puddles to the final gloss result
	G = max(g_R + g_G + g_B + g_A, puddles);

  #else
	float3	N 	= I.N.xyz	;
  #endif

 #else
	D.rgb	= 2*D.rgb*s_detail.Sample( smp_base, I.tcdbump).rgb;
 #endif
#else
	float3	N 	= I.N.xyz	;
#endif

	// hemi, sun, material
	float 	ms	= xmaterial	;
#ifdef USE_R2_STATIC_SUN
		 	ms 	= L.w		;
#endif

  // 2. Standart output
  float4     Ne = float4	(normalize(N), 									D.w			);
  O				= pack_gbuffer( 
								Ne,	// hemi
								float4 	(I.position.xyz + Ne.xyz*def_virtualh/2.h, 	0.95f			),	//
								float4	(D.x,	D.y,	D.z,						G			) );	// OUT: rgb.gloss

  return O;
}

#endif